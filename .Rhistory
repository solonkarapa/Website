geom_text(aes(x = initial_state, y = count + 0.5, label = count)) +
labs(x = "Initial State", y = "Number of presses") +
theme_linedraw(12)
devices <- c(1, 0, 0)
count <- 0
g <- expand.grid(1:3, 1:3) %>%
mutate(Var3 = (Var1 == Var2)) %>%
arrange(desc(Var3))
for (i in 1:(nrow(g)-3)) {
# checks
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
if (check_sound(devices)) {
out <- count
break
} else {
count = count + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)] # revert to initial state
print(count)
}
}
out
g
nrow(g)-3
devices
1 - devices[c(indices$Var1, indices$Var2)]
indices$Var1
permn(1:3)
combn(1:3)
combn(1:3, 3)
combn(1:3, 2)
g <- expand.grid(1:3, 1:3) %>%
mutate(Var3 = (Var1 == Var2)) %>%
arrange(desc(Var3, Var2))
g <- expand.grid(1:3, 1:3) %>%
mutate(Var3 = (Var1 == Var2),
bla = Var1+Var2) %>%
arrange(desc(Var3))
g
g %>% group_by(bla) %>% slice(min)
g %>% group_by(bla) %>% slice_min(bla)
?slice
g %>% group_by(bla) %>% slice_sample()
g %>% group_by(bla, Var3) %>% slice_sample()
g <- expand.grid(1:3, 1:3) %>%
mutate(Var3 = (Var1 == Var2),
add = Var1+Var2) %>%
group_by(bla, Var3) %>%
slice_sample() %>%
arrange(desc(Var3))
g <- expand.grid(1:3, 1:3) %>%
mutate(Var3 = (Var1 == Var2),
add = Var1+Var2) %>%
group_by(add, Var3) %>%
slice_sample() %>%
arrange(desc(Var3))
g
library(dplyr)
library(combinat)
library(purrr)
library(ggplot2)
# create a vector to store the status of each device (muted = 0, unmuted = 1)
devices <- c(1, 0, 1) # start from any state
# create a function to check if all devices are unmuted
check_sound <- function(devices) {
sum(devices) == 3
}
# Function to count the button presses for the remotes to achieve state {1, 1, 1} from any initial state.
# The function takes a vector of 3 binary values indicating whether each device is muted (0) or unmuted (1).
counter <- function(initial_state){
if(length(initial_state) != 3){
stop("The function works for only 3 states at the moment.")
}
devices <- initial_state
count <- 0 # initialize a counter for the number of presses
# first check if all unmuted
if (check_sound(devices)) {
out <- count
}
# check if changing all fixed the problem - this is step 3 above
#    devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)]
#    count <- count + 1 # add 1 count
#
#    if (check_sound(devices)) {
#        out <- count
#       } else {
#          devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)] # revert to initial state
#          }
# create indices to loop through
#g <- expand.grid(1:3, 1:3) %>%
#   mutate(Var3 = (Var1 == Var2)) %>%
#   arrange(desc(Var3))
g <- expand.grid(1:3, 1:3) %>%
mutate(Var3 = (Var1 == Var2),
add = Var1+Var2) %>%
group_by(add, Var3) %>%
slice_sample() %>%
arrange(desc(Var3))
for (i in 1:nrow(g)) {
# checks
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
if (check_sound(devices)) {
out <- count
break
} else {
count = count + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)] # revert to initial state
}
}
# check if changing all fixed the problem - this is step 3 above
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)]
#count <- count + 1 # add 1 count
if (check_sound(devices)) {
out <- count + 1
}
#} else {
#   devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)] # revert to initial state
#}
output <- data.frame(initial_state = paste(initial_state, collapse = " "),
count = out)
return(output)
}
counter(c(0, 0, 1))$count
# all possible states
states <- list(c(0, 0, 0), c(1, 1, 1),
c(1, 0, 0), c(0, 1, 0), c(0, 0, 1),
c(1, 1, 0), c(1, 0, 1), c(0, 1, 1))
res <- map_dfr(states, counter)
ggplot(res) +
geom_point(aes(x = initial_state, y = count)) +
geom_text(aes(x = initial_state, y = count + 0.5, label = count)) +
labs(x = "Initial State", y = "Number of presses") +
theme_linedraw(12)
g <- expand.grid(1:3, 1:3) %>%
mutate(Var3 = (Var1 == Var2),
add = Var1+Var2) %>%
group_by(add, Var3) %>%
slice_sample() %>%
arrange(desc(Var3))
g
count <- 0
devices <- c(1, 0, 0)
for (i in 1:(nrow(g)) {
for (i in 1:nrow(g)) {
# checks
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
if (check_sound(devices)) {
out <- count + 1
break
} else {
count = count + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)] # revert to initial state
print(count)
}
}
devices <- c(0, 1, 1)
count <- 0
g[1,]
i <- 1
# checks
indices <- g[i,]
indices
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
devices
if (check_sound(devices)) {
out <- count + 1
break
} else {
count = count + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)] # revert to initial state
print(count)
}
if (check_sound(devices)) {
out <- count + 1
#break
} else {
count = count + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)] # revert to initial state
print(count)
}
print(out)
print(count)
# Function to count the button presses for the remotes to achieve state {1, 1, 1} from any initial state.
# The function takes a vector of 3 binary values indicating whether each device is muted (0) or unmuted (1).
counter <- function(initial_state){
if(length(initial_state) != 3){
stop("The function works for only 3 states at the moment.")
}
devices <- initial_state
count <- 0 # initialize a counter for the number of presses
# first check if all unmuted
if (check_sound(devices)) {
out <- count
}
count <- 1
# check if changing all fixed the problem - this is step 3 above
#    devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)]
#    count <- count + 1 # add 1 count
#
#    if (check_sound(devices)) {
#        out <- count
#       } else {
#          devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)] # revert to initial state
#          }
# create indices to loop through
#g <- expand.grid(1:3, 1:3) %>%
#   mutate(Var3 = (Var1 == Var2)) %>%
#   arrange(desc(Var3))
g <- expand.grid(1:3, 1:3) %>%
mutate(Var3 = (Var1 == Var2),
add = Var1+Var2) %>%
group_by(add, Var3) %>%
slice_sample() %>%
arrange(desc(Var3))
for (i in 1:nrow(g)) {
# checks
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
if (check_sound(devices)) {
out <- count
break
} else {
count = count + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)] # revert to initial state
}
}
# check if changing all fixed the problem - this is step 3 above
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)]
#count <- count + 1 # add 1 count
if (check_sound(devices)) {
out <- count + 1
}
#} else {
#   devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)] # revert to initial state
#}
output <- data.frame(initial_state = paste(initial_state, collapse = " "),
count = out)
return(output)
}
# all possible states
states <- list(c(0, 0, 0), c(1, 1, 1),
c(1, 0, 0), c(0, 1, 0), c(0, 0, 1),
c(1, 1, 0), c(1, 0, 1), c(0, 1, 1))
res <- map_dfr(states, counter)
ggplot(res) +
geom_point(aes(x = initial_state, y = count)) +
geom_text(aes(x = initial_state, y = count + 0.5, label = count)) +
labs(x = "Initial State", y = "Number of presses") +
theme_linedraw(12)
# Function to count the button presses for the remotes to achieve state {1, 1, 1} from any initial state.
# The function takes a vector of 3 binary values indicating whether each device is muted (0) or unmuted (1).
counter <- function(initial_state){
if(length(initial_state) != 3){
stop("The function works for only 3 states at the moment.")
}
devices <- initial_state
count <- 0 # initialize a counter for the number of presses
# first check if all unmuted
if (check_sound(devices)) {
out <- count
}
# check if changing all fixed the problem - this is step 3 above
#    devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)]
#    count <- count + 1 # add 1 count
#
#    if (check_sound(devices)) {
#        out <- count
#       } else {
#          devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)] # revert to initial state
#          }
# create indices to loop through
#g <- expand.grid(1:3, 1:3) %>%
#   mutate(Var3 = (Var1 == Var2)) %>%
#   arrange(desc(Var3))
g <- expand.grid(1:3, 1:3) %>%
mutate(Var3 = (Var1 == Var2),
add = Var1+Var2) %>%
group_by(add, Var3) %>%
slice_sample() %>%
arrange(desc(Var3))
for (i in 1:nrow(g)) {
# checks
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
if (check_sound(devices)) {
out <- count
} else {
count = count + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)] # revert to initial state
}
}
# check if changing all fixed the problem - this is step 3 above
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)]
#count <- count + 1 # add 1 count
if (check_sound(devices)) {
out <- count + 1
}
#} else {
#   devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)] # revert to initial state
#}
output <- data.frame(initial_state = paste(initial_state, collapse = " "),
count = out)
return(output)
}
# all possible states
states <- list(c(0, 0, 0), c(1, 1, 1),
c(1, 0, 0), c(0, 1, 0), c(0, 0, 1),
c(1, 1, 0), c(1, 0, 1), c(0, 1, 1))
res <- map_dfr(states, counter)
ggplot(res) +
geom_point(aes(x = initial_state, y = count)) +
geom_text(aes(x = initial_state, y = count + 0.5, label = count)) +
labs(x = "Initial State", y = "Number of presses") +
theme_linedraw(12)
g
# checks
i <- 6
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
indices
if (check_sound(devices)) {
out <- count
print(out)
#break
} else {
count = out + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)] # revert to initial state
print(count)
}
count <- 0
g <- expand.grid(1:3, 1:3) %>%
mutate(Var3 = (Var1 == Var2),
add = Var1+Var2) %>%
group_by(add, Var3) %>%
slice_sample() %>%
arrange(desc(Var3))
for (i in 1:nrow(g)) {
# checks
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
if (check_sound(devices)) {
out <- count
print(out)
#break
} else {
count = out + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)] # revert to initial state
print(count)
}
}
g
nrow(g)
for (i in 1:nrow(g)) {
# checks
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
if (check_sound(devices)) {
out <- count + 1
print(out)
#break
} else {
count = out + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)] # revert to initial state
print(count)
}
}
# Function to count the button presses for the remotes to achieve state {1, 1, 1} from any initial state.
# The function takes a vector of 3 binary values indicating whether each device is muted (0) or unmuted (1).
counter <- function(initial_state){
if(length(initial_state) != 3){
stop("The function works for only 3 states at the moment.")
}
devices <- initial_state
count <- 0 # initialize a counter for the number of presses
# first check if all unmuted
if (check_sound(devices)) {
out <- count
}
# check if changing all fixed the problem - this is step 3 above
#    devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)]
#    count <- count + 1 # add 1 count
#
#    if (check_sound(devices)) {
#        out <- count
#       } else {
#          devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)] # revert to initial state
#          }
# create indices to loop through
#g <- expand.grid(1:3, 1:3) %>%
#   mutate(Var3 = (Var1 == Var2)) %>%
#   arrange(desc(Var3))
g <- expand.grid(1:3, 1:3) %>%
mutate(Var3 = (Var1 == Var2),
add = Var1+Var2) %>%
group_by(add, Var3) %>%
slice_sample() %>%
arrange(desc(Var3))
for (i in 1:nrow(g)) {
# checks
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
if (check_sound(devices)) {
out <- count + 1
} else {
count = count + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)] # revert to initial state
}
}
# check if changing all fixed the problem - this is step 3 above
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)]
count <- count + 1 # add 1 count
if (check_sound(devices)) {
out <- count #+ 1
}
#} else {
#   devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)] # revert to initial state
#}
output <- data.frame(initial_state = paste(initial_state, collapse = " "),
count = out)
return(output)
}
# all possible states
states <- list(c(0, 0, 0), c(1, 1, 1),
c(1, 0, 0), c(0, 1, 0), c(0, 0, 1),
c(1, 1, 0), c(1, 0, 1), c(0, 1, 1))
res <- map_dfr(states, counter)
ggplot(res) +
geom_point(aes(x = initial_state, y = count)) +
geom_text(aes(x = initial_state, y = count + 0.5, label = count)) +
labs(x = "Initial State", y = "Number of presses") +
theme_linedraw(12)
# Function to count the button presses for the remotes to achieve state {1, 1, 1} from any initial state.
# The function takes a vector of 3 binary values indicating whether each device is muted (0) or unmuted (1).
counter <- function(initial_state){
if(length(initial_state) != 3){
stop("The function works for only 3 states at the moment.")
}
devices <- initial_state
count <- 0 # initialize a counter for the number of presses
# first check if all unmuted
if (check_sound(devices)) {
out <- count
}
# create look out frame for indices to be changed
g <- expand.grid(1:3, 1:3) %>%
mutate(Var3 = (Var1 == Var2), add = Var1+Var2) %>%
group_by(add, Var3) %>%
slice_sample() %>%
arrange(desc(Var3))
# this is steps 1 and 2 above
for (i in 1:nrow(g)) {
# checks
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)] # change 1 or 2 remotes.
if (check_sound(devices)) {
out <- count + 1
} else {
count = count + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)] # revert to initial state
}
}
# check if changing all fixed the problem - this is step 3 above
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)]
count <- count + 1 # add 1 count
if (check_sound(devices)) {
out <- count
}
output <- data.frame(initial_state = paste(initial_state, collapse = " "),
count = out)
return(output)
}
counter(c(0, 0, 1))$count
# all possible states
states <- list(c(0, 0, 0), c(1, 1, 1),
c(1, 0, 0), c(0, 1, 0), c(0, 0, 1),
c(1, 1, 0), c(1, 0, 1), c(0, 1, 1))
res <- map_dfr(states, counter)
ggplot(res) +
geom_point(aes(x = initial_state, y = count)) +
geom_text(aes(x = initial_state, y = count + 0.5, label = count)) +
labs(x = "Initial State", y = "Number of presses") +
theme_linedraw(12)
counter(c(0, 0, 1))$count
# all possible states
states <- list(c(0, 0, 0), c(1, 1, 1),
c(1, 0, 0), c(0, 1, 0), c(0, 0, 1),
c(1, 1, 0), c(1, 0, 1), c(0, 1, 1))
res <- map_dfr(states, counter)
ggplot(res) +
geom_point(aes(x = initial_state, y = count)) +
geom_text(aes(x = initial_state, y = count + 0.5, label = count)) +
labs(x = "Initial State", y = "Number of presses") +
theme_linedraw(12)
g
blogdown:::serve_site()
blogdown:::serve_site()
knitr::opts_chunk$set(echo = TRUE)
knitr::include_graphics('/post/new_scientist_puzzle_212/trial2.png')
knitr::opts_chunk$set(echo = TRUE)
knitr::include_graphics('static/post/new_scientist_puzzle_212/trial2.png')
knitr::opts_chunk$set(echo = TRUE)
knitr::include_graphics('../../new_scientist_puzzle_212/trial2.png')
getwd()
knitr::opts_chunk$set(echo = TRUE)
knitr::include_graphics('~/../../new_scientist_puzzle_212/trial2.png')
knitr::opts_chunk$set(echo = TRUE)
knitr::include_graphics('~/static/post/new_scientist_puzzle_212/trial2.png')
knitr::opts_chunk$set(echo = TRUE)
knitr::include_graphics('static/post/new_scientist_puzzle_212/trial2.png')
blogdown:::insert_image_addin()
