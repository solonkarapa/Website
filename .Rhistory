if (check_sound(devices)) {
out <- paste("Sound is back! Total number of button presses:", count)
} else {
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)] # revert to initial state
}
# create indices to loop through
g <- expand.grid(1:3, 1:3) %>% mutate(Var3 = (Var1 == Var2)) %>% arrange(desc(Var3))
for (i in 1:nrow(g)) {
# checks
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
if (check_sound(devices)) {
out <- paste("Sound is back! Total number of button presses:", count)
} else {
count = count + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
}
}
res <- list(count, out)
return(res)
}
counter(c(0, 1, 0))
map(states, counter)
counter <- function(initial_state){
if(length(initial_state) != 3){
stop("The function works for only 3 states at the moment.")
}
devices <- initial_state
count <- 0 # initialize a counter for the number of presses
# first check if all unmuted
if (check_sound(devices)) {
out <- count
}
# check if changing all fixed the problem - this is step 3 above
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)]
count <- count + 1 # add 1 count
if (check_sound(devices)) {
out <- count
} else {
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)] # revert to initial state
}
# create indices to loop through
g <- expand.grid(1:3, 1:3) %>% mutate(Var3 = (Var1 == Var2)) %>% arrange(desc(Var3))
for (i in 1:nrow(g)) {
# checks
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
if (check_sound(devices)) {
out <- count
} else {
count = count + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
}
}
return(out)
}
counter(c(0, 1, 0))
map(states, counter)
?map
map_vec(states, counter)
res <- data.frame(initial_state = states, presses = map_vec(states, counter))
bla <- map_vec(states, counter)
res <- data.frame(initial_state = states, presses = bla)
unlist(states)
data.frame(states)
counter <- function(initial_state){
if(length(initial_state) != 3){
stop("The function works for only 3 states at the moment.")
}
devices <- initial_state
count <- 0 # initialize a counter for the number of presses
# first check if all unmuted
if (check_sound(devices)) {
out <- count
}
# check if changing all fixed the problem - this is step 3 above
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)]
count <- count + 1 # add 1 count
if (check_sound(devices)) {
out <- count
} else {
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)] # revert to initial state
}
# create indices to loop through
g <- expand.grid(1:3, 1:3) %>% mutate(Var3 = (Var1 == Var2)) %>% arrange(desc(Var3))
for (i in 1:nrow(g)) {
# checks
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
if (check_sound(devices)) {
out <- count
} else {
count = count + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
}
}
return(list(device, out))
}
counter(c(0, 1, 0))
counter <- function(initial_state){
if(length(initial_state) != 3){
stop("The function works for only 3 states at the moment.")
}
devices <- initial_state
count <- 0 # initialize a counter for the number of presses
# first check if all unmuted
if (check_sound(devices)) {
out <- count
}
# check if changing all fixed the problem - this is step 3 above
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)]
count <- count + 1 # add 1 count
if (check_sound(devices)) {
out <- count
} else {
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)] # revert to initial state
}
# create indices to loop through
g <- expand.grid(1:3, 1:3) %>% mutate(Var3 = (Var1 == Var2)) %>% arrange(desc(Var3))
for (i in 1:nrow(g)) {
# checks
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
if (check_sound(devices)) {
out <- count
} else {
count = count + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
}
}
return(list(devices, out))
}
counter(c(0, 1, 0))
counter <- function(initial_state){
if(length(initial_state) != 3){
stop("The function works for only 3 states at the moment.")
}
devices <- initial_state
count <- 0 # initialize a counter for the number of presses
# first check if all unmuted
if (check_sound(devices)) {
out <- count
}
# check if changing all fixed the problem - this is step 3 above
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)]
count <- count + 1 # add 1 count
if (check_sound(devices)) {
out <- count
} else {
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)] # revert to initial state
}
# create indices to loop through
g <- expand.grid(1:3, 1:3) %>% mutate(Var3 = (Var1 == Var2)) %>% arrange(desc(Var3))
for (i in 1:nrow(g)) {
# checks
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
if (check_sound(devices)) {
out <- count
} else {
count = count + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
}
}
return(list(initial_state = devices, count = out))
}
counter(c(0, 1, 0))
map(states, counter)
map_dfr(states, counter)
counter(c(0, 1, 0))
counter <- function(initial_state){
if(length(initial_state) != 3){
stop("The function works for only 3 states at the moment.")
}
devices <- initial_state
count <- 0 # initialize a counter for the number of presses
# first check if all unmuted
if (check_sound(devices)) {
out <- count
}
# check if changing all fixed the problem - this is step 3 above
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)]
count <- count + 1 # add 1 count
if (check_sound(devices)) {
out <- count
} else {
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)] # revert to initial state
}
# create indices to loop through
g <- expand.grid(1:3, 1:3) %>% mutate(Var3 = (Var1 == Var2)) %>% arrange(desc(Var3))
for (i in 1:nrow(g)) {
# checks
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
if (check_sound(devices)) {
out <- count
} else {
count = count + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
}
}
return(list(initial_state = as.character(devices), count = out))
}
counter(c(0, 1, 0))
counter <- function(initial_state){
if(length(initial_state) != 3){
stop("The function works for only 3 states at the moment.")
}
devices <- initial_state
count <- 0 # initialize a counter for the number of presses
# first check if all unmuted
if (check_sound(devices)) {
out <- count
}
# check if changing all fixed the problem - this is step 3 above
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)]
count <- count + 1 # add 1 count
if (check_sound(devices)) {
out <- count
} else {
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)] # revert to initial state
}
# create indices to loop through
g <- expand.grid(1:3, 1:3) %>% mutate(Var3 = (Var1 == Var2)) %>% arrange(desc(Var3))
for (i in 1:nrow(g)) {
# checks
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
if (check_sound(devices)) {
out <- count
} else {
count = count + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
}
}
return(list(initial_state = character(devices), count = out))
}
counter(c(0, 1, 0))
character(c(0, 1, 0))
as.character(c(0, 1, 0))
as.character(0, 1, 0)
c(0, 1, 0)
map_dfr(states, counter)
counter <- function(initial_state){
if(length(initial_state) != 3){
stop("The function works for only 3 states at the moment.")
}
devices <- initial_state
count <- 0 # initialize a counter for the number of presses
# first check if all unmuted
if (check_sound(devices)) {
out <- count
}
# check if changing all fixed the problem - this is step 3 above
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)]
count <- count + 1 # add 1 count
if (check_sound(devices)) {
out <- count
} else {
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)] # revert to initial state
}
# create indices to loop through
g <- expand.grid(1:3, 1:3) %>% mutate(Var3 = (Var1 == Var2)) %>% arrange(desc(Var3))
for (i in 1:nrow(g)) {
# checks
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
if (check_sound(devices)) {
out <- count
} else {
count = count + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
}
}
return(list(initial_state = evices, count = out))
}
counter <- function(initial_state){
if(length(initial_state) != 3){
stop("The function works for only 3 states at the moment.")
}
devices <- initial_state
count <- 0 # initialize a counter for the number of presses
# first check if all unmuted
if (check_sound(devices)) {
out <- count
}
# check if changing all fixed the problem - this is step 3 above
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)]
count <- count + 1 # add 1 count
if (check_sound(devices)) {
out <- count
} else {
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)] # revert to initial state
}
# create indices to loop through
g <- expand.grid(1:3, 1:3) %>% mutate(Var3 = (Var1 == Var2)) %>% arrange(desc(Var3))
for (i in 1:nrow(g)) {
# checks
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
if (check_sound(devices)) {
out <- count
} else {
count = count + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
}
}
return(list(initial_state = devices, count = out))
}
map_dfr(states, counter)
map_dfr(states, counter, id = "initial_state")
map_dfr(states, counter, .id = "initial_state")
character(c(0, 1, 0))
map_dfc(states, counter, .id = "initial_state")
map_dfc(states, counter)
map_dfr(states, counter, .id = "states")
map(states, counter)
counter(c(0, 1, 0))
counter <- function(initial_state){
if(length(initial_state) != 3){
stop("The function works for only 3 states at the moment.")
}
devices <- initial_state
count <- 0 # initialize a counter for the number of presses
# first check if all unmuted
if (check_sound(devices)) {
out <- count
}
# check if changing all fixed the problem - this is step 3 above
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)]
count <- count + 1 # add 1 count
if (check_sound(devices)) {
out <- count
} else {
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)] # revert to initial state
}
# create indices to loop through
g <- expand.grid(1:3, 1:3) %>% mutate(Var3 = (Var1 == Var2)) %>% arrange(desc(Var3))
for (i in 1:nrow(g)) {
# checks
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
if (check_sound(devices)) {
out <- count
} else {
count = count + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
}
}
return(data.frame(initial_state = devices, count = out))
}
counter(c(0, 1, 0))
data.frame(initial_state = devices, count = 4)
data.frame(initial_state = c(devices), count = 4)
data.frame(initial_state = as.character(devices), count = 4)
data.frame(initial_state = character(devices), count = 4)
as.character(devices)
c(as.character(devices))
paste(as.character(devices), sep=" ")
paste(as.character(devices), collapse=" ")
paste(devices, collapse=" ")
data.frame(initial_state = paste(devices, collapse = " "), count = 4)
counter <- function(initial_state){
if(length(initial_state) != 3){
stop("The function works for only 3 states at the moment.")
}
devices <- initial_state
count <- 0 # initialize a counter for the number of presses
# first check if all unmuted
if (check_sound(devices)) {
out <- count
}
# check if changing all fixed the problem - this is step 3 above
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)]
count <- count + 1 # add 1 count
if (check_sound(devices)) {
out <- count
} else {
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)] # revert to initial state
}
# create indices to loop through
g <- expand.grid(1:3, 1:3) %>% mutate(Var3 = (Var1 == Var2)) %>% arrange(desc(Var3))
for (i in 1:nrow(g)) {
# checks
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
if (check_sound(devices)) {
out <- count
} else {
count = count + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
}
}
return(data.frame(initial_state = paste(devices, collapse = " "), count = out))
}
counter(c(0, 1, 0))
map(states, counter)
map_dfr(states, counter)
states
counter <- function(initial_state){
if(length(initial_state) != 3){
stop("The function works for only 3 states at the moment.")
}
devices <- initial_state
count <- 0 # initialize a counter for the number of presses
# first check if all unmuted
if (check_sound(devices)) {
out <- count
}
# check if changing all fixed the problem - this is step 3 above
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)]
count <- count + 1 # add 1 count
if (check_sound(devices)) {
out <- count
} else {
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)] # revert to initial state
}
# create indices to loop through
g <- expand.grid(1:3, 1:3) %>% mutate(Var3 = (Var1 == Var2)) %>% arrange(desc(Var3))
for (i in 1:nrow(g)) {
# checks
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
if (check_sound(devices)) {
out <- count
} else {
count = count + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
}
}
return(data.frame(initial_state = paste(initial_state, collapse = " "), count = out))
}
counter(c(0, 1, 0))
map_dfr(states, counter)
library(ggplot2)
res <- map_dfr(states, counter)
plot(res$initial_state, res$count)
class(res$initial_state)
ggplot(res) +
geom_point(aes(x = initial_state, y = count))
?geom_text
ggplot(res) +
geom_point(aes(x = initial_state, y = count)) +
geom_label(aes(initial_state, y = count))
ggplot(res) +
geom_point(aes(x = initial_state, y = count)) +
geom_label(aes(x = initial_state, y = count))
ggplot(res) +
geom_point(aes(x = initial_state, y = count)) +
geom_text(aes(x = initial_state, y = count))
ggplot(res) +
geom_point(aes(x = initial_state, y = count)) +
geom_text(aes(x = initial_state, y = count, label = count))
ggplot(res) +
geom_point(aes(x = initial_state, y = count)) +
geom_text(aes(x = initial_state, y = count + 0.5, label = count))
res
permn(c(0, 0, 1)
)
?permn
(permn(6))
permn(1)
combn(c(0, 1, 1), 3)
combn(c(0, 1, 1), 3)
?combn
combn(c(0, 1, 1), 3)
combn(c("0, 1, 1"), 3)
combn(c("0", "1", "1"), 3)
combn(c("T", "M", "N"), 3)
mv1 = c("Tennis", "Badminton", "Football", "Athletics", "Chess")
mv1
# All Combinations of Two Elements
combn(mv1,2)
permn(c("T", "M", "N"), 3)
permn(c("T", "M", "N"))
permn(c("0", "0", "1"))
permn(c(0, 1, 1)
)
states <- list(c(0, 0, 0), c(1, 1, 1),
c(1, 0, 0), c(0, 1, 0), c(0, 0, 1),
c(1, 1, 0), c(1, 0, 1), c(0, 1, 1))
states
res <- map_dfr(states, counter)
ggplot(res) +
geom_point(aes(x = initial_state, y = count)) +
geom_text(aes(x = initial_state, y = count + 0.5, label = count))
ggplot(res) +
geom_point(aes(x = initial_state, y = count)) +
geom_text(aes(x = initial_state, y = count + 0.5, label = count)) +
labs(x = "Initial State", y = "Number of presses to getting the sound back on")
ggplot(res) +
geom_point(aes(x = initial_state, y = count)) +
geom_text(aes(x = initial_state, y = count + 0.5, label = count)) +
labs(x = "Initial State", y = "Number of presses")
ggplot(res) +
geom_point(aes(x = initial_state, y = count)) +
geom_text(aes(x = initial_state, y = count + 0.5, label = count)) +
labs(x = "Initial State", y = "Number of presses") +
theme_classic()
ggplot(res) +
geom_point(aes(x = initial_state, y = count)) +
geom_text(aes(x = initial_state, y = count + 0.5, label = count)) +
labs(x = "Initial State", y = "Number of presses") +
theme_linedraw()
ggplot(res) +
geom_point(aes(x = initial_state, y = count)) +
geom_text(aes(x = initial_state, y = count + 0.5, label = count)) +
labs(x = "Initial State", y = "Number of presses") +
theme_linedraw(12)
counter(c(1, 1, 0))
counter(c(1, 1, 0))$count
expand.grid(1:3, 1:3)
