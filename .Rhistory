}
g
nrow(g)
for (i in 1:nrow(g)) {
# checks
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
if (check_sound(devices)) {
out <- count + 1
print(out)
#break
} else {
count = out + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)] # revert to initial state
print(count)
}
}
# Function to count the button presses for the remotes to achieve state {1, 1, 1} from any initial state.
# The function takes a vector of 3 binary values indicating whether each device is muted (0) or unmuted (1).
counter <- function(initial_state){
if(length(initial_state) != 3){
stop("The function works for only 3 states at the moment.")
}
devices <- initial_state
count <- 0 # initialize a counter for the number of presses
# first check if all unmuted
if (check_sound(devices)) {
out <- count
}
# check if changing all fixed the problem - this is step 3 above
#    devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)]
#    count <- count + 1 # add 1 count
#
#    if (check_sound(devices)) {
#        out <- count
#       } else {
#          devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)] # revert to initial state
#          }
# create indices to loop through
#g <- expand.grid(1:3, 1:3) %>%
#   mutate(Var3 = (Var1 == Var2)) %>%
#   arrange(desc(Var3))
g <- expand.grid(1:3, 1:3) %>%
mutate(Var3 = (Var1 == Var2),
add = Var1+Var2) %>%
group_by(add, Var3) %>%
slice_sample() %>%
arrange(desc(Var3))
for (i in 1:nrow(g)) {
# checks
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
if (check_sound(devices)) {
out <- count + 1
} else {
count = count + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)] # revert to initial state
}
}
# check if changing all fixed the problem - this is step 3 above
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)]
count <- count + 1 # add 1 count
if (check_sound(devices)) {
out <- count #+ 1
}
#} else {
#   devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)] # revert to initial state
#}
output <- data.frame(initial_state = paste(initial_state, collapse = " "),
count = out)
return(output)
}
# all possible states
states <- list(c(0, 0, 0), c(1, 1, 1),
c(1, 0, 0), c(0, 1, 0), c(0, 0, 1),
c(1, 1, 0), c(1, 0, 1), c(0, 1, 1))
res <- map_dfr(states, counter)
ggplot(res) +
geom_point(aes(x = initial_state, y = count)) +
geom_text(aes(x = initial_state, y = count + 0.5, label = count)) +
labs(x = "Initial State", y = "Number of presses") +
theme_linedraw(12)
# Function to count the button presses for the remotes to achieve state {1, 1, 1} from any initial state.
# The function takes a vector of 3 binary values indicating whether each device is muted (0) or unmuted (1).
counter <- function(initial_state){
if(length(initial_state) != 3){
stop("The function works for only 3 states at the moment.")
}
devices <- initial_state
count <- 0 # initialize a counter for the number of presses
# first check if all unmuted
if (check_sound(devices)) {
out <- count
}
# create look out frame for indices to be changed
g <- expand.grid(1:3, 1:3) %>%
mutate(Var3 = (Var1 == Var2), add = Var1+Var2) %>%
group_by(add, Var3) %>%
slice_sample() %>%
arrange(desc(Var3))
# this is steps 1 and 2 above
for (i in 1:nrow(g)) {
# checks
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)] # change 1 or 2 remotes.
if (check_sound(devices)) {
out <- count + 1
} else {
count = count + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)] # revert to initial state
}
}
# check if changing all fixed the problem - this is step 3 above
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)]
count <- count + 1 # add 1 count
if (check_sound(devices)) {
out <- count
}
output <- data.frame(initial_state = paste(initial_state, collapse = " "),
count = out)
return(output)
}
counter(c(0, 0, 1))$count
# all possible states
states <- list(c(0, 0, 0), c(1, 1, 1),
c(1, 0, 0), c(0, 1, 0), c(0, 0, 1),
c(1, 1, 0), c(1, 0, 1), c(0, 1, 1))
res <- map_dfr(states, counter)
ggplot(res) +
geom_point(aes(x = initial_state, y = count)) +
geom_text(aes(x = initial_state, y = count + 0.5, label = count)) +
labs(x = "Initial State", y = "Number of presses") +
theme_linedraw(12)
counter(c(0, 0, 1))$count
# all possible states
states <- list(c(0, 0, 0), c(1, 1, 1),
c(1, 0, 0), c(0, 1, 0), c(0, 0, 1),
c(1, 1, 0), c(1, 0, 1), c(0, 1, 1))
res <- map_dfr(states, counter)
ggplot(res) +
geom_point(aes(x = initial_state, y = count)) +
geom_text(aes(x = initial_state, y = count + 0.5, label = count)) +
labs(x = "Initial State", y = "Number of presses") +
theme_linedraw(12)
g
blogdown:::serve_site()
blogdown:::serve_site()
knitr::opts_chunk$set(echo = TRUE)
knitr::include_graphics('/post/new_scientist_puzzle_212/trial2.png')
knitr::opts_chunk$set(echo = TRUE)
knitr::include_graphics('static/post/new_scientist_puzzle_212/trial2.png')
knitr::opts_chunk$set(echo = TRUE)
knitr::include_graphics('../../new_scientist_puzzle_212/trial2.png')
getwd()
knitr::opts_chunk$set(echo = TRUE)
knitr::include_graphics('~/../../new_scientist_puzzle_212/trial2.png')
knitr::opts_chunk$set(echo = TRUE)
knitr::include_graphics('~/static/post/new_scientist_puzzle_212/trial2.png')
knitr::opts_chunk$set(echo = TRUE)
knitr::include_graphics('static/post/new_scientist_puzzle_212/trial2.png')
blogdown:::insert_image_addin()
blogdown:::serve_site()
library(dplyr)
library(combinat)
library(purrr)
library(ggplot2)
# create a vector to store the status of each device (muted = 0, unmuted = 1)
devices <- c(1, 0, 1) # start from any state
# create a function to check if all devices are unmuted
check_sound <- function(devices) {
sum(devices) == 3
}
# Function to count the button presses for the remotes to achieve state {1, 1, 1} from any initial state.
# The function takes a vector of 3 binary values indicating whether each device is muted (0) or unmuted (1).
counter <- function(initial_state){
if(length(initial_state) != 3){
stop("The function works for only 3 states at the moment.")
}
devices <- initial_state
count <- 0 # initialize a counter for the number of presses
# first check if all unmuted
if (check_sound(devices)) {
out <- count
}
# create look out frame for indices to be changed
g <- expand.grid(1:3, 1:3) %>%
mutate(Var3 = (Var1 == Var2), add = Var1+Var2) %>%
group_by(add, Var3) %>%
slice_sample() %>%
arrange(desc(Var3))
# this is steps 1 and 2 above
for (i in 1:nrow(g)) {
# checks
indices <- g[i,]
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)] # change 1 or 2 remotes.
if (check_sound(devices)) {
out <- count + 1
} else {
count = count + 1
devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)] # revert to initial state
}
}
# check if changing all fixed the problem - this is step 3 above
devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)]
count <- count + 1 # add 1 count
if (check_sound(devices)) {
out <- count
}
output <- data.frame(initial_state = paste(initial_state, collapse = " "),
count = out)
return(output)
}
counter(c(0, 0, 1))$count
blogdown:::serve_site()
blogdown:::serve_site()
library(gtools)
library(stringi)
library(stringr)
library(rebus)
colour <- c("blue", "yellow", "pink", "red", "green") # all the different colours
numb <- 1:5 # the size index (1 is the largest)
opt <- paste0(rep(colour, each = 5), "_", numb) # combine colour and index
perms <- permutations(n = 25, r = 5, v = opt, repeats.allowed = F) # all the combinations of 5 dolls
##### adding restrictions
# 1: select only the ones where blue is the smallest doll
blue_smallest_doll <- which(perms[,5] == "blue_5") # select only the ones where blue is the smallest doll
perms2 <- perms[blue_smallest_doll,]
# 2: select only the combinations where each color appears once and indexes are sorted correctly
combs <- c()
for(i in 1:nrow(perms2)){
perms3 <- stri_split_fixed(perms2[i,], "_", simplify = T) # split the vectors into two
dupl <- sum(stri_duplicated(perms3[,1])) # check for uniqueness
sorted <- is.unsorted(perms3[,2], strictly = T) # check for correct order
if(dupl == 0 & sorted == 0){
combs <- rbind(perms2[i,], combs)
}
}
combs
# 3: apply first restrictions
pattern_pink_red <- ("pink" %R% zero_or_more(WRD) %R% "red") # no doll contains a pink with a red doll anywhere within it
ind <- c()
for(i in 1:nrow(combs)){
splitted <- stri_split_fixed(combs[i,], "_", simplify = T) # split the vectors into two
ind[i] <- str_detect(paste(splitted[,1], collapse = ""), pattern_pink_red,
negate = T) # find patterns
}
combs_update <- combs[ind, ]
combs_update
##### interpretation 1
pattern_yellow_green_pink <- ("yellow" %R% zero_or_more(WRD) %R% "green" %R% zero_or_more(WRD) %R% "pink") # no yellow doll contains a green doll with a pink inside it.
ind <- c()
for(i in 1:nrow(combs_update)){
splitted <- stri_split_fixed(combs_update[i,], "_", simplify = T) # split the vectors into two
ind[i] <- str_detect(paste(splitted[,1], collapse = ""), pattern_yellow_green_pink,
negate = T) # find patterns
}
combs_update[ind, ]
# option 2
pattern_green_pink <- ("green" %R% zero_or_more(WRD) %R% "pink") # no green doll with a pink doll anywhere within it
ind <- c()
for(i in 1:nrow(combs_update)){
splitted <- stri_split_fixed(combs_update[i,], "_", simplify = T) # split the vectors into two
ind[i] <- str_detect(paste(splitted[,1], collapse = ""), or(pattern_yellow_green_pink, pattern_green_pink),
negate = T) # find patterns
}
combs_update[ind, ]
combs
combs_update
ind <- c()
for(i in 1:nrow(combs_update)){
splitted <- stri_split_fixed(combs_update[i,], "_", simplify = T) # split the vectors into two
ind[i] <- str_detect(paste(splitted[,1], collapse = ""), or(pattern_green_pink),
negate = T) # find patterns
}
combs_update[ind, ]
# option 2
pattern_green_pink <- ("green" %R% zero_or_more(WRD) %R% "pink") # no green doll with a pink doll anywhere within it
ind <- c()
for(i in 1:nrow(combs_update)){
splitted <- stri_split_fixed(combs_update[i,], "_", simplify = T) # split the vectors into two
ind[i] <- str_detect(paste(splitted[,1], collapse = ""), or(pattern_yellow_green_pink, pattern_green_pink),
negate = T) # find patterns
}
combs_update[ind, ]
# option 3
pattern_yellow_green<- ("yellow" %R% zero_or_more(WRD) %R% "green")
ind <- c()
for(i in 1:nrow(combs_update)){
splitted <- stri_split_fixed(combs_update[i,], "_", simplify = T) # split the vectors into two
ind[i] <- str_detect(paste(splitted[,1], collapse = ""), or(pattern_yellow_green_pink, pattern_green_pink, pattern_yellow_green),
negate = T) # find patterns
}
combs_update[ind, ]
# option 3
pattern_yellow_green<- ("yellow" %R% zero_or_more(WRD) %R% "green")
ind <- c()
for(i in 1:nrow(combs_update)){
splitted <- stri_split_fixed(combs_update[i,], "_", simplify = T) # split the vectors into two
ind[i] <- str_detect(paste(splitted[,1], collapse = ""), or(pattern_yellow_green_pink, pattern_green_pink, pattern_yellow_green),
negate = T) # find patterns
}
combs_update[ind, ]
blogdown:::serve_site()
library(gtools)
library(stringi)
library(stringr)
library(rebus)
colour <- c("blue", "yellow", "pink", "red", "green") # all the different colours
numb <- 1:5 # the size index (1 is the largest)
opt <- paste0(rep(colour, each = 5), "_", numb) # combine colour and index
perms <- permutations(n = 25, r = 5, v = opt, repeats.allowed = F) # all the combinations of 5 dolls
##### adding restrictions
# 1: select only the ones where blue is the smallest doll
blue_smallest_doll <- which(perms[,5] == "blue_5") # blue is the smallest doll
perms_2 <- perms[blue_smallest_doll,]
# 2: select only the combinations where each colour appears once and indexes are sorted correctly
combs <- c()
for(i in 1:nrow(perms2)){
perms3 <- stri_split_fixed(perms2[i,], "_", simplify = T) # split the vectors into two
dupl <- sum(stri_duplicated(perms3[,1])) # check for uniqueness
sorted <- is.unsorted(perms3[,2], strictly = T) # check for correct order
if(dupl == 0 & sorted == 0){
combs <- rbind(perms2[i,], combs)
}
}
# pkgs used in this post
library(gtools)
library(stringi)
library(stringr)
library(rebus)
colour <- c("blue", "yellow", "pink", "red", "green") # all the different colours
numb <- 1:5 # the size index (1 is the largest)
opt <- paste0(rep(colour, each = 5), "_", numb) # combine colour and index
perms <- permutations(n = 25, r = 5, v = opt, repeats.allowed = F) # all the combinations of 5 dolls
##### adding restrictions
# 1: select only the ones where blue is the smallest doll
blue_smallest_doll <- which(perms[,5] == "blue_5") # blue is the smallest doll
perms2 <- perms[blue_smallest_doll,]
# 2: select only the combinations where each colour appears once and indexes are sorted correctly
combs <- c()
for(i in 1:nrow(perms2)){
perms3 <- stri_split_fixed(perms2[i,], "_", simplify = T) # split the vectors into two
dupl <- sum(stri_duplicated(perms3[,1])) # check for uniqueness
sorted <- is.unsorted(perms3[,2], strictly = T) # check for correct order
if(dupl == 0 & sorted == 0){
combs <- rbind(perms2[i,], combs)
}
}
combs
# 3: apply first restriction
pattern_pink_red <- ("pink" %R% zero_or_more(WRD) %R% "red") # no doll contains a pink with a red doll anywhere within it
ind <- c()
for(i in 1:nrow(combs)){
splitted <- stri_split_fixed(combs[i,], "_", simplify = T) # split the vectors into two
ind[i] <- str_detect(paste(splitted[,1], collapse = ""), pattern_pink_red, negate = T) # find patterns
}
combs_update <- combs[ind, ]
combs_update
12-3
##### 1st interpretation
pattern_yellow_green_pink <- ("yellow" %R% zero_or_more(WRD) %R% "green" %R% zero_or_more(WRD) %R% "pink") # no yellow doll contains a green doll with a pink inside it.
ind <- c()
for(i in 1:nrow(combs_update)){
splitted <- stri_split_fixed(combs_update[i,], "_", simplify = T) # split the vectors into two
ind[i] <- str_detect(paste(splitted[,1], collapse = ""), pattern_yellow_green_pink,
negate = T) # find patterns
}
combs_update[ind, ]
# option 2
pattern_green_pink <- ("green" %R% zero_or_more(WRD) %R% "pink") # no green doll with a pink doll anywhere within it
ind <- c()
for(i in 1:nrow(combs_update)){
splitted <- stri_split_fixed(combs_update[i,], "_", simplify = T) # split the vectors into two
ind[i] <- str_detect(paste(splitted[,1], collapse = ""), or(pattern_yellow_green_pink, pattern_green_pink),
negate = T) # find patterns
}
combs_update[ind, ]
#### 3rd interpretation
pattern_yellow_green<- ("yellow" %R% zero_or_more(WRD) %R% "green")
ind <- c()
for(i in 1:nrow(combs_update)){
splitted <- stri_split_fixed(combs_update[i,], "_", simplify = T) # split the vectors into two
ind[i] <- str_detect(paste(splitted[,1], collapse = ""), or(pattern_yellow_green_pink, pattern_green_pink, pattern_yellow_green),
negate = T) # find patterns
}
combs_update[ind, ]
##### 1st interpretation
pattern_yellow_green_pink <- ("yellow" %R% zero_or_more(WRD) %R% "green" %R% zero_or_more(WRD) %R% "pink") # no yellow doll contains a green doll with a pink inside it.
ind <- c()
for(i in 1:nrow(combs_update)){
splitted <- stri_split_fixed(combs_update[i,], "_", simplify = T) # split the vectors into two
ind[i] <- str_detect(paste(splitted[,1], collapse = ""), pattern_yellow_green_pink, negate = T) # find patterns
}
combs_update[ind, ]
# 3: apply first restriction
pattern_pink_red <- ("pink" %R% zero_or_more(WRD) %R% "red") # no doll contains a pink with a red doll anywhere within it
ind <- c()
for(i in 1:nrow(combs)){
splitted <- stri_split_fixed(combs[i,], "_", simplify = T) # split the vectors into two
ind[i] <- str_detect(paste(splitted[,1], collapse = ""), pattern_pink_red, negate = T) # find patterns
}
combs_update <- combs[ind, ]
combs_update
##### 2nd interpretation
pattern_green_pink <- ("green" %R% zero_or_more(WRD) %R% "pink") # no green doll with a pink doll anywhere within it
ind <- c()
for(i in 1:nrow(combs_update)){
splitted <- stri_split_fixed(combs_update[i,], "_", simplify = T) # split the vectors into two
ind[i] <- str_detect(paste(splitted[,1], collapse = ""), or(pattern_yellow_green_pink, pattern_green_pink),
negate = T) # find patterns
}
combs_update[ind, ]
##### 2nd interpretation
pattern_green_pink <- ("green" %R% zero_or_more(WRD) %R% "pink") # no green doll with a pink doll anywhere within it
ind <- c()
for(i in 1:nrow(combs_update)){
splitted <- stri_split_fixed(combs_update[i,], "_", simplify = T) # split the vectors into two
ind[i] <- str_detect(paste(splitted[,1], collapse = ""), and(pattern_yellow_green_pink, pattern_green_pink),
negate = T) # find patterns
}
##### 2nd interpretation
pattern_green_pink <- ("green" %R% zero_or_more(WRD) %R% "pink") # no green doll with a pink doll anywhere within it
ind <- c()
for(i in 1:nrow(combs_update)){
splitted <- stri_split_fixed(combs_update[i,], "_", simplify = T) # split the vectors into two
ind[i] <- str_detect(paste(splitted[,1], collapse = ""), (pattern_yellow_green_pink, pattern_green_pink),
##### 2nd interpretation
pattern_green_pink <- ("green" %R% zero_or_more(WRD) %R% "pink") # no green doll with a pink doll anywhere within it
ind <- c()
for(i in 1:nrow(combs_update)){
splitted <- stri_split_fixed(combs_update[i,], "_", simplify = T) # split the vectors into two
ind[i] <- str_detect(paste(splitted[,1], collapse = ""), c(pattern_yellow_green_pink, pattern_green_pink),
negate = T) # find patterns
}
combs_update[ind, ]
#### 3rd interpretation
pattern_yellow_green<- ("yellow" %R% zero_or_more(WRD) %R% "green")
ind <- c()
for(i in 1:nrow(combs_update)){
splitted <- stri_split_fixed(combs_update[i,], "_", simplify = T) # split the vectors into two
ind[i] <- str_detect(paste(splitted[,1], collapse = ""), or(pattern_yellow_green_pink, pattern_green_pink, pattern_yellow_green),
negate = T) # find patterns
}
combs_update[ind, ]
#### 3rd interpretation
pattern_yellow_green<- ("yellow" %R% zero_or_more(WRD) %R% "green")
ind <- c()
for(i in 1:nrow(combs_update)){
splitted <- stri_split_fixed(combs_update[i,], "_", simplify = T) # split the vectors into two
ind[i] <- str_detect(paste(splitted[,1], collapse = ""), c(pattern_yellow_green_pink, pattern_green_pink, pattern_yellow_green),
negate = T) # find patterns
}
combs_update[ind, ]
blogdown:::serve_site()
knitr::include_graphics("./Tree_fig.pdf")
knitr::include_graphics("./Tree_fig2.pdf")
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
# pkgs used in this post
library(gtools)
library(stringi)
library(stringr)
library(rebus)
colour <- c("blue", "yellow", "pink", "red", "green") # all the different colours
numb <- 1:5 # the size index (1 is the largest)
opt <- paste0(rep(colour, each = 5), "_", numb) # combine colour and index
perms <- permutations(n = 25, r = 5, v = opt, repeats.allowed = F) # all the combinations of 5 dolls
##### adding restrictions
# 1: select only the ones where blue is the smallest doll
blue_smallest_doll <- which(perms[,5] == "blue_5") # blue is the smallest doll
perms2 <- perms[blue_smallest_doll,]
# 2: select only the combinations where each colour appears once and indexes are sorted correctly
combs <- c()
for(i in 1:nrow(perms2)){
perms3 <- stri_split_fixed(perms2[i,], "_", simplify = T) # split the vectors into two
dupl <- sum(stri_duplicated(perms3[,1])) # check for uniqueness
sorted <- is.unsorted(perms3[,2], strictly = T) # check for correct order
if(dupl == 0 & sorted == 0){
combs <- rbind(perms2[i,], combs)
}
}
combs
perms2
head(perms2)
class(perms2)
str(perms3)
?stri_split_fixed
bla <- lapply(perms2, stri_split_fixed, pattern = "_", simplify = T)
str(bla)
str(perms3)
head(perms3)
bla <- do.call(cbind(lapply(perms2, stri_split_fixed, pattern = "_", simplify = T))
)
bla <- do.call(cbind, (lapply(perms2, stri_split_fixed, pattern = "_", simplify = T)))
str(bla)
?vappply
?vapply
bla <- sapply(perms2, stri_split_fixed, pattern = "_", simplify = T)
str(bla)
perms2[i,]
library(purrr)
map(perms2, stri_split_fixed, pattern = "_", simplify = T)
bla2 <- map(perms2, stri_split_fixed, pattern = "_", simplify = F)
str(bla2)
perms3
?map
str(perms2)
str(perms2[i,])
str(perms2[i,])
i
