bla2 <- map(vec, my_fun)
matrix(unlist(bla2), ncol = 5, byrow = TRUE)
dim(bla2)
str(bla2)
bla2 <- map(1:nrow(perms2), my_fun)
matrix(unlist(bla2), ncol = 5, byrow = TRUE)
my_fun <- function(x, data, pattern = NULL){
if(is.null(pattern)){
perms3 <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
dupl <- sum(stri_duplicated(perms3[,1])) # check for uniqueness
sorted <- is.unsorted(perms3[,2], strictly = T) #
if(dupl == 0 & sorted == 0){
combs <- data[x,]
}
}else{
splitted <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
ind <- str_detect(paste(splitted[,1], collapse = ""), pattern = pattern, negate = T) # find patterns
combs <- data[ind,]
}
return(combs)
}
combs
# 2: select only the combinations where each colour appears once and indexes are sorted correctly
combs <- c()
for(i in 1:nrow(perms2)){
perms3 <- stri_split_fixed(perms2[i,], "_", simplify = T) # split the vectors into two
dupl <- sum(stri_duplicated(perms3[,1])) # check for uniqueness
sorted <- is.unsorted(perms3[,2], strictly = T) # check for correct order
if(dupl == 0 & sorted == 0){
combs <- rbind(perms2[i,], combs)
}
}
combs
# 3: apply first restriction
# no doll contains a pink with a red doll anywhere within it
pattern_pink_red <- ("pink" %R% zero_or_more(WRD) %R% "red")
my_fun(1, combs, pattern_pink_red)
my_fun <- function(x, data, pattern = NULL){
if(is.null(pattern)){
perms3 <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
dupl <- sum(stri_duplicated(perms3[,1])) # check for uniqueness
sorted <- is.unsorted(perms3[,2], strictly = T) #
if(dupl == 0 & sorted == 0){
combs <- data[x,]
}
}else{
splitted <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
ind <- str_detect(paste(splitted[,1], collapse = ""), pattern = pattern, negate = T) # find patterns
combs <- data[ind,]
}
return(combs)
}
my_fun(1, combs, pattern_pink_red)
my_fun(2, combs, pattern_pink_red)
data <- combs
x <- 2
splitted <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
x <- 1
splitted <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
splitted
ind <- str_detect(paste(splitted[,1], collapse = ""), pattern = pattern_pink_red, negate = T) # find patterns
ind
if(ind == 1){
combs <- data[x,]
}
my_fun(2, combs, pattern_pink_red)
my_fun <- function(x, data, pattern = NULL){
if(is.null(pattern)){
perms3 <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
dupl <- sum(stri_duplicated(perms3[,1])) # check for uniqueness
sorted <- is.unsorted(perms3[,2], strictly = T) #
if(dupl == 0 & sorted == 0){
combs <- data[x,]
}
}else{
splitted <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
ind <- str_detect(paste(splitted[,1], collapse = ""), pattern = pattern, negate = T) # find patterns
if(ind == 1){
combs <- data[x,]
}
}
return(combs)
}
my_fun(2, combs, pattern_pink_red)
ind
combs[x,]
data[x,]
my_fun <- function(x, data, pattern = NULL){
if(is.null(pattern)){
perms3 <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
dupl <- sum(stri_duplicated(perms3[,1])) # check for uniqueness
sorted <- is.unsorted(perms3[,2], strictly = T) #
if(dupl == 0 & sorted == 0){
combs <- data[x,]
}
}else{
splitted <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
ind <- str_detect(paste(splitted[,1], collapse = ""), pattern = pattern, negate = T) # find patterns
#if(ind == 1){
#   combs <- data[x,]
#}
}
return(ind)
}
my_fun(2, combs, pattern_pink_red)
combs
# 2: select only the combinations where each colour appears once and indexes are sorted correctly
combs <- c()
for(i in 1:nrow(perms2)){
perms3 <- stri_split_fixed(perms2[i,], "_", simplify = T) # split the vectors into two
dupl <- sum(stri_duplicated(perms3[,1])) # check for uniqueness
sorted <- is.unsorted(perms3[,2], strictly = T) # check for correct order
if(dupl == 0 & sorted == 0){
combs <- rbind(perms2[i,], combs)
}
}
my_fun(2, combs, pattern_pink_red)
my_fun <- function(x, data, pattern = NULL){
if(is.null(pattern)){
perms3 <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
dupl <- sum(stri_duplicated(perms3[,1])) # check for uniqueness
sorted <- is.unsorted(perms3[,2], strictly = T) #
if(dupl == 0 & sorted == 0){
out <- data[x,]
}
}else{
splitted <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
ind <- str_detect(paste(splitted[,1], collapse = ""), pattern = pattern, negate = T) # find patterns
if(ind == 1){
out <- data[x,]
}
}
return(out)
}
my_fun(2, combs, pattern_pink_red)
nrow(combs)
my_fun(1:nrow(combs), combs, pattern_pink_red)
map(1:nrow(combs), my_fun, combs, pattern_pink_red)
my_fun <- function(x, data, pattern = NULL){
if(is.null(pattern)){
perms3 <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
dupl <- sum(stri_duplicated(perms3[,1])) # check for uniqueness
sorted <- is.unsorted(perms3[,2], strictly = T) #
if(dupl == 0 & sorted == 0){
out <- data[x,]
}
}else{
splitted <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
ind <- str_detect(paste(splitted[,1], collapse = ""), pattern = pattern, negate = T) # find patterns
if(ind == 1){
out <- data[x,]
}
}
return(out)
}
bla2
matrix(unlist(bla2), ncol = 5, byrow = TRUE)
1:nrow(combs)
map(1:nrow(combs), my_fun, data = combs, pattern = pattern_pink_red)
myfun(2, combs, pattern_pink_red)
my_fun <- function(x, data, pattern = NULL){
if(is.null(pattern)){
perms3 <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
dupl <- sum(stri_duplicated(perms3[,1])) # check for uniqueness
sorted <- is.unsorted(perms3[,2], strictly = T) #
if(dupl == 0 & sorted == 0){
out <- data[x,]
}
}else{
splitted <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
ind <- str_detect(paste(splitted[,1], collapse = ""), pattern = pattern, negate = T) # find patterns
if(ind == 1){
out <- data[x,]
}
}
return(out)
}
my_fun(2, combs, pattern_pink_red)
my_fun(3, combs, pattern_pink_red)
combs
combs[3,]
data <- combs
x <- 3
splitted <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
ind <- str_detect(paste(splitted[,1], collapse = ""), pattern = pattern_pink_red, negate = T) # find patterns
ind
my_fun <- function(x, data, pattern = NULL){
if(is.null(pattern)){
perms3 <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
dupl <- sum(stri_duplicated(perms3[,1])) # check for uniqueness
sorted <- is.unsorted(perms3[,2], strictly = T) #
if(dupl == 0 & sorted == 0){
out <- data[x,]
}
}else{
splitted <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
ind <- str_detect(paste(splitted[,1], collapse = ""), pattern = pattern, negate = T) # find patterns
if(ind == 1){
out <- data[x,]
}else{
out <- c()
}
}
return(out)
}
my_fun(3, combs, pattern_pink_red)
map(1:nrow(combs), my_fun, data = combs, pattern = pattern_pink_red)
matrix(unlist(bla3), ncol = 5, byrow = TRUE)
bla3 <- map(1:nrow(combs), my_fun, data = combs, pattern = pattern_pink_red)
matrix(unlist(bla3), ncol = 5, byrow = TRUE)
##### add restrictions
# 1: select only the ones where blue is the smallest doll
blue_smallest_doll <- which(perms[,5] == "blue_5") # blue is the smallest doll
perms2 <- perms[blue_smallest_doll,]
# 2: select only the combinations where each colour appears once and indexes are sorted correctly
combinations <- matrix(unlist(map(1:nrow(perms2), my_fun)),  ncol = 5, byrow = TRUE)
# 2: select only the combinations where each colour appears once and indexes are sorted correctly
combinations <- matrix(unlist(map(1:nrow(perms2), my_fun, data = perms2)),  ncol = 5, byrow = TRUE)
my_fun
# 2: select only the combinations where each colour appears once and indexes are sorted correctly
combinations <- matrix(unlist(map(1:nrow(perms2), my_fun, data = perms2, pattern = NULL)), ncol = 5, byrow = TRUE)
# define function to use
my_fun <- function(x, data, pattern = NULL){
if(is.null(pattern)){
perms3 <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
dupl <- sum(stri_duplicated(perms3[,1])) # check for uniqueness
sorted <- is.unsorted(perms3[,2], strictly = T) #
if(dupl == 0 & sorted == 0){
out <- data[x,]
} else{
out <- c()
}
}else{
splitted <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
ind <- str_detect(paste(splitted[,1], collapse = ""), pattern = pattern, negate = T) # find patterns
if(ind == 1){
out <- data[x,]
}else{
out <- c()
}
}
return(out)
}
# 2: select only the combinations where each colour appears once and indexes are sorted correctly
combinations <- matrix(unlist(map(1:nrow(perms2), my_fun, data = perms2, pattern = NULL)), ncol = 5, byrow = TRUE)
combinations
# define function to use
my_fun <- function(x, data, pattern = NULL){
if(is.null(pattern)){
perms3 <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
dupl <- sum(stri_duplicated(perms3[,1])) # check for uniqueness
sorted <- is.unsorted(perms3[,2], strictly = T) #
if(dupl == 0 & sorted == 0){
out <- data[x,]
} else{
out <- c()
}
}else{
splitted <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
ind <- str_detect(paste(splitted[,1], collapse = ""), pattern = pattern, negate = T) # find patterns
if(ind == 1){
out <- data[x,]
}else{
out <- c()
}
}
return(out)
}
# 2: select only the combinations where each colour appears once and indexes are sorted correctly
combinations <- matrix(unlist(map(1:nrow(perms2), my_fun, data = perms2, pattern = NULL)), ncol = 5, byrow = TRUE)
# 2: select only the combinations where each colour appears once and indexes are sorted correctly
combinations <- matrix(unlist(map(1:nrow(perms2), my_fun, data = perms2)), ncol = 5, byrow = TRUE)
combinations
# 3: apply first restriction
# no doll contains a pink with a red doll anywhere within it
pattern_pink_red <- ("pink" %R% zero_or_more(WRD) %R% "red")
combinations_update <- matrix(unlist(map(1:nrow(combinations), my_fun, data = combinations, pattern = pattern_pink_red)), ncol = 5, byrow = TRUE)
combinations_update
##### 1st interpretation
# no yellow doll contains a green doll with a pink inside it
pattern_yellow_green_pink <- ("yellow" %R% zero_or_more(WRD) %R% "green" %R% zero_or_more(WRD) %R% "pink")
combinations_update1 <- matrix(unlist(map(1:nrow(combinations_update), my_fun, data = combinations, pattern = pattern_yellow_green_pink)), ncol = 5, byrow = TRUE)
combinations_update1
##### 1st interpretation
# no yellow doll contains a green doll with a pink inside it
pattern_yellow_green_pink <- ("yellow" %R% zero_or_more(WRD) %R% "green" %R% zero_or_more(WRD) %R% "pink")
combinations_update1 <- matrix(unlist(map(1:nrow(combinations_update), my_fun, data = combinations_update, pattern = pattern_yellow_green_pink)), ncol = 5, byrow = TRUE)
combinations_update1
##### 2nd interpretation
# no green doll with a pink doll anywhere within it
pattern_green_pink <- ("green" %R% zero_or_more(WRD) %R% "pink")
combinations_update1 <- matrix(unlist(map(1:nrow(combinations_update), my_fun, data = combinations_update, pattern = or(pattern_yellow_green_pink, pattern_green_pink))), ncol = 5, byrow = TRUE)
combinations_update1
#### 3rd interpretation
pattern_yellow_green<- ("yellow" %R% zero_or_more(WRD) %R% "green")
combinations_update3 <- matrix(unlist(map(1:nrow(combinations_update), my_fun, data = combinations_update, pattern = or(pattern_yellow_green_pink, pattern_green_pink, pattern_yellow_green))), ncol = 5, byrow = TRUE)
combinations_update3
>apply
?map
bla3 <- map(1:nrow(combs), my_fun, data = combs, pattern = pattern_pink_red)
str(bla3)
bla3 <- map_vec(1:nrow(combs), my_fun, data = combs, pattern = pattern_pink_red)
?unlist
# pkgs used in this post
library(gtools)
library(stringi)
library(stringr)
library(rebus)
library(purrr)
colour <- c("blue", "yellow", "pink", "red", "green") # all the different colours
numb <- 1:5 # the size index (1 is the largest)
opt <- paste0(rep(colour, each = 5), "_", numb) # combine colour and index
perms <- permutations(n = 25, r = 5, v = opt, repeats.allowed = F) # all the combinations of 5 dolls
# define function to use
my_fun <- function(x, data, pattern = NULL){
if(is.null(pattern)){
perms3 <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
dupl <- sum(stri_duplicated(perms3[,1])) # check for uniqueness
sorted <- is.unsorted(perms3[,2], strictly = T) # check for correct order
if(dupl == 0 & sorted == 0){
out <- data[x,]
} else{
out <- c()
}
}else{
splitted <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
ind <- str_detect(paste(splitted[,1], collapse = ""), pattern = pattern, negate = T) # find patterns
if(ind == 1){
out <- data[x,]
}else{
out <- c()
}
}
return(out)
}
##### add restrictions
# 1: select only the ones where blue is the smallest doll
blue_smallest_doll <- which(perms[,5] == "blue_5") # blue is the smallest doll
perms2 <- perms[blue_smallest_doll,]
# 2: select only the combinations where each colour appears once and indexes are sorted correctly
combinations <- matrix( # simplify into a matrix
unlist( # simplify output of map()
map(1:nrow(perms2), my_fun, data = perms2)), # apply my_fun to all rows of perms2
ncol = 5, byrow = TRUE)
combinations
# pkgs used in this post
library(gtools)
library(stringi)
library(stringr)
library(rebus)
library(purrr)
colour <- c("blue", "yellow", "pink", "red", "green") # all the different colours
numb <- 1:5 # the size index (1 is the largest)
opt <- paste0(rep(colour, each = 5), "_", numb) # combine colour and index
perms <- permutations(n = 25, r = 5, v = opt, repeats.allowed = F) # all the combinations of 5 dolls
# define function to use
my_fun <- function(x, data, pattern = NULL){
if(is.null(pattern)){
perms3 <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
dupl <- sum(stri_duplicated(perms3[,1])) # check for uniqueness
sorted <- is.unsorted(perms3[,2], strictly = T) # check for correct order
if(dupl == 0 & sorted == 0){
out <- data[x,]
} else{
out <- c()
}
}else{
splitted <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
ind <- str_detect(paste(splitted[,1], collapse = ""), pattern = pattern, negate = T) # find patterns
if(ind == 1){
out <- data[x,]
}else{
out <- c()
}
}
return(out)
}
##### add restrictions
# 1: select only the ones where blue is the smallest doll
blue_smallest_doll <- which(perms[,5] == "blue_5") # blue is the smallest doll
perms2 <- perms[blue_smallest_doll,]
# 2: select only the combinations where each colour appears once and indexes are sorted correctly
combinations <- matrix( # simplify into a matrix
unlist( # simplify output of map()
map(1:nrow(perms2), my_fun, data = perms2)), # apply my_fun to all rows of perms2
ncol = 5, byrow = TRUE)
combinations
# pkgs used in this post
library(gtools)
library(stringi)
library(stringr)
library(rebus)
library(purrr)
colour <- c("blue", "yellow", "pink", "red", "green") # all the different colours
numb <- 1:5 # the size index (1 is the largest)
opt <- paste0(rep(colour, each = 5), "_", numb) # combine colour and index
perms <- permutations(n = 25, r = 5, v = opt, repeats.allowed = F) # all the combinations of 5 dolls
# define function to use
my_fun <- function(x, data, pattern = NULL){
if(is.null(pattern)){
perms3 <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
dupl <- sum(stri_duplicated(perms3[,1])) # check for uniqueness
sorted <- is.unsorted(perms3[,2], strictly = T) # check for correct order
if(dupl == 0 & sorted == 0){
out <- data[x,]
} else{
out <- c()
}
}else{
splitted <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
ind <- str_detect(paste(splitted[,1], collapse = ""), pattern = pattern, negate = T) # find patterns
if(ind == 1){
out <- data[x,]
}else{
out <- c()
}
}
return(out)
}
##### add restrictions
# 1: select only the ones where blue is the smallest doll
blue_smallest_doll <- which(perms[,5] == "blue_5") # blue is the smallest doll
perms2 <- perms[blue_smallest_doll,]
# 2: select only the combinations where each colour appears once and indexes are sorted correctly
combinations <- matrix( # simplify into a matrix
unlist( # simplify output of map()
map(1:nrow(perms2), my_fun, data = perms2)), # apply my_fun to all rows of perms2
ncol = 5, byrow = TRUE)
combinations
# pkgs used in this post
library(gtools)
library(stringi)
library(stringr)
library(rebus)
library(purrr)
colour <- c("blue", "yellow", "pink", "red", "green") # all the different colours
numb <- 1:5 # the size index (1 is the largest)
opt <- paste0(rep(colour, each = 5), "_", numb) # combine colour and index
perms <- permutations(n = 25, r = 5, v = opt, repeats.allowed = F) # all the combinations of 5 dolls
# define function to use
my_fun <- function(x, data, pattern = NULL){
if(is.null(pattern)){
perms3 <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
dupl <- sum(stri_duplicated(perms3[,1])) # check for uniqueness
sorted <- is.unsorted(perms3[,2], strictly = T) # check for correct order
if(dupl == 0 & sorted == 0){
out <- data[x,]
} else{
out <- c()
}
}else{
splitted <- stri_split_fixed(data[x,], "_", simplify = T) # split the vectors into two
ind <- str_detect(paste(splitted[,1], collapse = ""), pattern = pattern, negate = T) # find patterns
if(ind == 1){
out <- data[x,]
}else{
out <- c()
}
}
return(out)
}
##### add restrictions
# 1: select only the ones where blue is the smallest doll
blue_smallest_doll <- which(perms[,5] == "blue_5") # blue is the smallest doll
perms2 <- perms[blue_smallest_doll,]
# 2: select only the combinations where each colour appears once and indexes are sorted correctly
combinations <- matrix( # simplify into a matrix
unlist( # simplify output of map()
map(1:nrow(perms2), my_fun, data = perms2)), # apply my_fun to all rows of perms2
ncol = 5, byrow = TRUE)
combinations
##### 1st interpretation
# no yellow doll contains a green doll with a pink inside it
pattern_yellow_green_pink <- ("yellow" %R% zero_or_more(WRD) %R% "green" %R% zero_or_more(WRD) %R% "pink")
combinations_update1 <- matrix(
unlist(
map(1:nrow(combinations_update), my_fun, data = combinations_update, pattern = pattern_yellow_green_pink)),
ncol = 5, byrow = TRUE)
# 3: apply first restriction
# no doll contains a pink with a red doll anywhere within it
pattern_pink_red <- ("pink" %R% zero_or_more(WRD) %R% "red")
combinations_update <- matrix(
unlist(
map(1:nrow(combinations), my_fun, data = combinations, pattern = pattern_pink_red)),
ncol = 5, byrow = TRUE)
combinations_update
##### 1st interpretation
# no yellow doll contains a green doll with a pink inside it
pattern_yellow_green_pink <- ("yellow" %R% zero_or_more(WRD) %R% "green" %R% zero_or_more(WRD) %R% "pink")
combinations_update1 <- matrix(
unlist(
map(1:nrow(combinations_update), my_fun, data = combinations_update, pattern = pattern_yellow_green_pink)),
ncol = 5, byrow = TRUE)
combinations_update1
##### 2nd interpretation
# no green doll with a pink doll anywhere within it
pattern_green_pink <- ("green" %R% zero_or_more(WRD) %R% "pink")
combinations_update2 <- matrix(
unlist(
map(1:nrow(combinations_update), my_fun, data = combinations_update, pattern = or(pattern_yellow_green_pink, pattern_green_pink))),
ncol = 5, byrow = TRUE)
combinations_update2
#### 3rd interpretation
pattern_yellow_green<- ("yellow" %R% zero_or_more(WRD) %R% "green")
combinations_update3 <- matrix(
unlist(
map(1:nrow(combinations_update), my_fun, data = combinations_update, pattern = or(pattern_yellow_green_pink, pattern_green_pink, pattern_yellow_green))),
ncol = 5, byrow = TRUE)
combinations_update3
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
