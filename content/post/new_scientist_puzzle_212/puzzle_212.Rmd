---
title: "# 212 Puzzle from the New Scientist"
author: Me
date: '2023-02-08'
slug: puzzle212
categories:
  - puzzle
tags: [puzzle]
subtitle: ''
summary: ''
authors: []
lastmod: '2023-03-30T14:27:06Z'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: yes
projects: []
draft: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

[Puzzle #212](https://www.newscientist.com/article/mg25734291-300-puzzle-212-can-you-work-out-how-sams-mum-can-unmute-her-television/) from the New Scientist is: 

> “Why isn’t the sound working?”, Mum muttered as she hit the mute key on the remote control.

> “You’ve probably got the wrong remote, Mum”, Sam said. “Remember, it’s the long, thin one for the television, the wide one for the set-top box and the little one for the speakers. Which one did you mute?”

> “I can’t remember”, said Mum, as she got her thinking cap on to try to fix things.

> To get sound, all three remotes have to be unmuted. Mum came up with the most efficient system for cycling through the possible combinations of muting and unmuting, and got to work.

> What is the maximum number of presses needed if she wanted to be sure of getting the sound back?

## Solution

Each remote can be in one of two states {mute or unmute}. There are three remotes, so in total there are $2^3=8$ possible states. 

An example of a state is {mute, mute, unmute}. The desired state is {unmute, unmute, unmute}. 

We’ll start by finding an efficient system for cycling through the possible combinations of states. 

The system goes as follows:

1) choose a remote and press the mute/unmute button. 
    a) If no sound, repeat step 1, but this time choosing a different remote. 
        - The worst-case scenario requires 3 presses. We may need to cycle through 1, 2 or all 3 remotes. 

2) After testing all three remotes in step 1 and provided there is no sound we start over again but now choosing two remotes together and pressing the mute/unmute buttons. 
    a) If no sound, repeat step 2, but this time choosing the other remotes.
        - The worst-case scenario this requires 3 presses. That is we can choose, to press remote 1 and remote 2, remote 1 and remote 3, and, remote 1 and remote 3. In total 3 choices. 

3) For last step, we can press all three remotes simultaneously. 
   - This requires 1 press.

So the maximum number of presses is 7: 3 at step 1, 3 at step 2 and 1 at step 3. 
Note, there is no requirement to follow steps 1 to 3 in this order. Any order works. In fact, the code below implements step 3 first. 

## Code 
We represent the status of each device using binary values 0 and 1 where muted = 0, and unmuted = 1. So the state {mute, mute, unmute} is represented with c(0, 0, 1).

```{r, warning=F, message=F}
library(dplyr)
library(combinat)
library(purrr)
library(ggplot2)

# create a vector to store the status of each device (muted = 0, unmuted = 1)
devices <- c(1, 0, 1) # start from any state

# create a function to check if all devices are unmuted
check_sound <- function(devices) {
    sum(devices) == 3
}
```

The function `counter()` counts the maximum button presses needed to go from any initial state to c(1, 1, 1), which corresponds to the unmuted state. 

```{r}
# Function to count the button presses for the remotes to achieve state {1, 1, 1} from any initial state. 
# The function takes a vector of 3 binary values indicating whether each device is muted (0) or unmuted (1).

counter <- function(initial_state){
   
   if(length(initial_state) != 3){
      stop("The function works for only 3 states at the moment.")
   }
   
   devices <- initial_state 

   count <- 0 # initialize a counter for the number of presses

    # first check if all unmuted
    if (check_sound(devices)) {
       out <- count
       }
    
    # check if changing all fixed the problem - this is step 3 above
    devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)]
    count <- count + 1 # add 1 count
    
    if (check_sound(devices)) {
        out <- count
       } else {
          devices[c(1, 2, 3)] <- 1 - devices[c(1, 2, 3)] # revert to initial state
          }

     # create indices to loop through
      g <- expand.grid(1:3, 1:3) %>% mutate(Var3 = (Var1 == Var2)) %>% arrange(desc(Var3))
   
    for (i in 1:nrow(g)) {
       # checks  
       indices <- g[i,]
       devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
    
      if (check_sound(devices)) {
          out <- count
         } else {
            count = count + 1
            devices[c(indices$Var1, indices$Var2)] <- 1 - devices[c(indices$Var1, indices$Var2)]
            }
    }
      
      return(data.frame(initial_state = paste(initial_state, collapse = " "), count = out))
}
```

As an example, if we start from state c(1, 1, 0), and based on the system described above, we need at most 3 presses to get the sound back on. 

```{r}
counter(c(1, 1, 0))$count
```

The plot shows the maximun number of presses needed to get the sound back from each state. Since the code first checks step 3 (pressing all three remotes simultaneously) then if we start from c(0, 0, 0) we are 1 press away from unmuting the TV. 

```{r}
# all possible states
states <- list(c(0, 0, 0), c(1, 1, 1), 
               c(1, 0, 0), c(0, 1, 0), c(0, 0, 1),
               c(1, 1, 0), c(1, 0, 1), c(0, 1, 1)) 

res <- map_dfr(states, counter)

ggplot(res) +
   geom_point(aes(x = initial_state, y = count)) +
   geom_text(aes(x = initial_state, y = count + 0.5, label = count)) +
   labs(x = "Initial State", y = "Number of presses") +
   theme_linedraw(12)
```

